<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualisation Guldin - Triangle (Fig 4.1) - Fixe + Surface V4 (Lathe)</title>
    <script>
        // Setup MathJax Configuration before loading the script
        MathJax = {
          loader: {load: ['[tex]/braket']},
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']],
            processEscapes: true,
            processEnvironments: true,
            tags: 'none',
            packages: {'[+]': ['braket']},
             macros: {
              vec: ['\\overrightarrow{#1}', 1]
            }
          },
          options: {
            skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
          },
          startup: {
            ready: () => {
              console.log('MathJax is ready');
              MathJax.startup.defaultReady();
              setTimeout(() => {
                 if (typeof updateInfoAndCalculations === 'function') {
                     updateInfoAndCalculations();
                 }
               }, 100);
            }
          }
        };
      </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
    <style>
        body { margin: 0; font-family: "Computer Modern Sans", sans-serif; background-color: #f4f4f4; display: flex; height: 100vh; overflow: hidden; }
        #controls-container { width: 360px; padding: 15px; background-color: #fff; overflow-y: auto; border-right: 1px solid #ccc; box-shadow: 2px 0 5px rgba(0,0,0,0.1); font-size: 14px;}
        #canvas-container { flex-grow: 1; position: relative; background-color: #e0e0e0; }
        canvas { display: block; }
        #controls-container h2 { margin-top: 0; font-size: 1.2em; color: #0056b3; border-bottom: 1px solid #eee; padding-bottom: 5px; }
        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; font-size: 0.9em;}
        input[type="number"], input[type="range"] { width: calc(100% - 12px); margin-bottom: 5px; padding: 4px; border: 1px solid #ccc; border-radius: 3px;}
        output { font-weight: bold; margin-left: 5px; display: inline-block; }
        #info, #calculationDetails { background-color: rgba(255, 255, 255, 0.95); padding: 12px; border-radius: 5px; font-size: 0.95em; line-height: 1.6; margin-top: 15px; border: 1px solid #ddd; word-wrap: break-word; }
        #calculationDetails { min-height: 200px; }
        #info span { font-weight: bold; color: #0056b3; }
        hr { border: 0; border-top: 1px solid #eee; margin: 10px 0; }
        mjx-container[jax="CHTML"][display="true"] { display: block; margin: 0.8em 0 !important; overflow-x: auto !important; overflow-y: hidden; text-align: left !important; font-size: 100% !important; padding: 5px 0; }
        mjx-math[display="false"] { font-size: 110% !important; vertical-align: -0.1em; }
    </style>
</head>
<body>
    <div id="controls-container">
        <h2>Paramètres (Fig 4.1)</h2>
        <div class="control-group">
            <label for="sideA">Côté a (sur Oy):</label>
            <input type="number" id="sideA" value="3" min="0.1" step="0.1">
        </div>
        <div class="control-group">
            <label for="sideB">Côté b (sur Ox):</label>
            <input type="number" id="sideB" value="4" min="0.1" step="0.1">
        </div>
        <div class="control-group">
            <label for="angleSlider">Angle de Rotation (autour de Oy):</label>
            <input type="range" id="angleSlider" min="0" max="360" value="90" step="1">
            <output id="angleOutput">90</output>°
        </div>
        <div id="info">
            <b>Informations Calculées:</b><br>
            Longueur $L$: <span id="length"></span><br>
            Centroïde G (Local): ($x_G$: <span id="centroidX"></span>, $y_G$: <span id="centroidY"></span>, 0)<br>
            Distance $R_G$ à l'axe Y: <span id="distRg"></span><br>
            <hr>
            <b>Surface Générée $S_A$ (Guldin):</b><br>
            Angle($\alpha$): <span id="angleRadDisplay"></span> rad<br>
            $S_A = L \times (\alpha \times R_G)$: <span id="guldinArea"></span>
        </div>
        <div id="calculationDetails">
             <b>Détails du Calcul ($x_G$):</b><br>
             Chargement MathJax...
        </div>
    </div>
    <div id="canvas-container"></div>

    <script type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } } </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        let scene, camera, renderer, controls;
        let lineOA, lineOB, lineAB, triangleGroup;
        let generatedDisk, generatedLatheSurface; // Changed variable name
        let centroidPathLine, centroidObject;
        let axisLabels = {};
        let font = null;
        let gridHelper;

        let sideA = 3;
        let sideB = 4;
        let rotationAngleRad = THREE.MathUtils.degToRad(90);

        const lineMaterial = new THREE.LineBasicMaterial({ color: 0xcc0000, linewidth: 3 });
        const axisMaterial = new THREE.LineBasicMaterial({ color: 0x0000cc });
        const surfaceMaterial = new THREE.MeshPhongMaterial({ color: 0x00aa00, side: THREE.DoubleSide, transparent: true, opacity: 0.6, }); // Green for Lathe
        const diskMaterial = new THREE.MeshPhongMaterial({ color: 0x0088dd, side: THREE.DoubleSide, transparent: true, opacity: 0.6, }); // Blue for Disk
        const centroidMaterial = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
        const centroidPathMaterial = new THREE.LineBasicMaterial({ color: 0xffaa00, linewidth: 1.5 });
        const gridColorCenter = 0x666666;
        const gridColorLines = 0xaaaaaa;

        const container = document.getElementById('canvas-container');
        const sideAInput = document.getElementById('sideA');
        const sideBInput = document.getElementById('sideB');
        const angleSlider = document.getElementById('angleSlider');
        const angleOutput = document.getElementById('angleOutput');
        const lengthEl = document.getElementById('length');
        const centroidXEl = document.getElementById('centroidX');
        const centroidYEl = document.getElementById('centroidY');
        const distRgEl = document.getElementById('distRg');
        const guldinAreaEl = document.getElementById('guldinArea');
        const angleRadDisplayEl = document.getElementById('angleRadDisplay');
        const calcDetailsEl = document.getElementById('calculationDetails');

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f5ff);

            const aspect = container.clientWidth / container.clientHeight;
            camera = new THREE.PerspectiveCamera(60, aspect, 0.1, 1000);
            camera.position.set(sideB * 1.5, sideA * 1.5, Math.max(sideA, sideB) * 2.5);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(sideB / 2, sideA / 2, 0);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight.position.set(10, 15, 10);
            scene.add(directionalLight);

            const axesHelper = new THREE.AxesHelper(Math.max(sideA, sideB) * 1.5);
            scene.add(axesHelper);
            createOrUpdateGrid();
            loadFontAndCreateLabels();

            const axisYPoints = [new THREE.Vector3(0, -sideA * 0.5, 0), new THREE.Vector3(0, sideA * 1.5, 0)];
            const axisYGeom = new THREE.BufferGeometry().setFromPoints(axisYPoints);
            scene.add(new THREE.Line(axisYGeom, axisMaterial));

            const centroidGeom = new THREE.SphereGeometry(0.1, 16, 8);
            centroidObject = new THREE.Mesh(centroidGeom, centroidMaterial);
            scene.add(centroidObject);

            createOrUpdateTriangle();
            createOrUpdateSurfaces();
            createOrUpdateCentroidPath();

            sideAInput.addEventListener('input', handleParamChange);
            sideBInput.addEventListener('input', handleParamChange);
            angleSlider.addEventListener('input', handleAngleChange);
            window.addEventListener('resize', onWindowResize);

            animate();
        }

        function loadFontAndCreateLabels() {
             const loader = new FontLoader();
             loader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_regular.typeface.json',
                function (loadedFont) { font = loadedFont; createOrUpdateAxisLabels(); }, undefined,
                function (err) { console.error('Font loading error:', err); if(calcDetailsEl) calcDetailsEl.innerHTML += "<br><span style='color:red;'>Erreur: Police non chargée.</span>"; }
            );
        }

        function createOrUpdateAxisLabels() {
            if (!font) return;
            Object.values(axisLabels).forEach(label => label && scene.remove(label));
            axisLabels = {};
            const textMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 });
            const textHeight = 0.02;
            const currentMaxSize = Math.max(sideA, sideB, 1);
            const textSize = currentMaxSize * 0.08 + 0.1;
            const textParams = { font: font, size: textSize, height: textHeight };
            const offset = currentMaxSize * 1.15 + 0.2;

            ['X', 'Y', 'Z'].forEach(axis => {
                const textGeo = new TextGeometry(axis, textParams);
                textGeo.center();
                const textMesh = new THREE.Mesh(textGeo, textMaterial);
                if (axis === 'X') textMesh.position.set(offset, 0.1, 0);
                if (axis === 'Y') textMesh.position.set(0.1, offset, 0);
                if (axis === 'Z') textMesh.position.set(0, 0.1, offset);
                scene.add(textMesh);
                axisLabels[axis.toLowerCase()] = textMesh;
            });
        }

         function createOrUpdateGrid() {
             if(gridHelper) scene.remove(gridHelper);
             const gridSize = Math.max(sideA, sideB, 2) * 1.5;
             const gridDivisions = Math.ceil(gridSize / 0.5);
             gridHelper = new THREE.GridHelper(gridSize, gridDivisions, gridColorCenter, gridColorLines);
             gridHelper.rotation.x = Math.PI / 2; // Lay flat on XY
             scene.add(gridHelper);
         }

        function createOrUpdateTriangle() {
            if (triangleGroup) scene.remove(triangleGroup);
            triangleGroup = new THREE.Group();
            const O = new THREE.Vector3(0, 0, 0);
            const A = new THREE.Vector3(0, sideA, 0);
            const B = new THREE.Vector3(sideB, 0, 0);
            const geomOA = new THREE.BufferGeometry().setFromPoints([O, A]);
            lineOA = new THREE.Line(geomOA, lineMaterial);
            triangleGroup.add(lineOA);
            const geomOB = new THREE.BufferGeometry().setFromPoints([O, B]);
            lineOB = new THREE.Line(geomOB, lineMaterial);
            triangleGroup.add(lineOB);
            const geomAB = new THREE.BufferGeometry().setFromPoints([A, B]);
            lineAB = new THREE.Line(geomAB, lineMaterial);
            triangleGroup.add(lineAB);
            scene.add(triangleGroup); // Add the stationary triangle group
        }

        function createOrUpdateSurfaces() {
            // Remove previous surfaces from the main scene
            if (generatedDisk) { scene.remove(generatedDisk); generatedDisk.geometry.dispose(); generatedDisk = null; }
            if (generatedLatheSurface) { scene.remove(generatedLatheSurface); generatedLatheSurface.geometry.dispose(); generatedLatheSurface = null; }

            if (rotationAngleRad <= 0.001) return; // Exit if no rotation

            // --- Surface from OB (Disk Segment rotating around Y) ---
            // CircleGeometry phiStart=0 starts at positive X-axis. Correct.
            const diskGeometry = new THREE.CircleGeometry(sideB, 64, 0, rotationAngleRad);
            diskGeometry.rotateX(-Math.PI / 2); // Align flat on XZ plane
            generatedDisk = new THREE.Mesh(diskGeometry, diskMaterial);
            scene.add(generatedDisk); // Add directly to scene

            // --- Surface from AB (Generated by Lathe around Y) ---
            // Define the profile of the line AB in the XY plane (r=x, y=y)
            const profileAB = [
                new THREE.Vector2(0, sideA),     // Point A: radius=0, y=a
                new THREE.Vector2(sideB, 0)      // Point B: radius=b, y=0
            ];
            const segments = 32;
            const phiStart = Math.PI / 2; // Start from +90° (positive Y-axis)
            const latheGeometry = new THREE.LatheGeometry(
                profileAB,
                segments,
                phiStart,
                rotationAngleRad // phiLength
             );
            generatedLatheSurface = new THREE.Mesh(latheGeometry, surfaceMaterial); // Use distinct name
            // LatheGeometry is generated around Y axis correctly positioned.
            scene.add(generatedLatheSurface); // Add directly to scene
        }

        function createOrUpdateCentroidPath() {
            if (centroidPathLine) { scene.remove(centroidPathLine); centroidPathLine.geometry.dispose(); centroidPathLine = null; }

            const lengthOA = sideA;
            const lengthOB = sideB;
            const lengthAB = Math.sqrt(sideA * sideA + sideB * sideB);
            const totalLength = lengthOA + lengthOB + lengthAB;
            if (totalLength === 0) { centroidObject.visible = false; return; }

            const centroidLocalX = (sideB * (sideB + lengthAB)) / (2 * totalLength);
            const centroidLocalY = (sideA * (sideA + lengthAB)) / (2 * totalLength);
            const centroidLocal = new THREE.Vector3(centroidLocalX, centroidLocalY, 0);

            if (rotationAngleRad <= 0.001) {
                centroidObject.position.copy(centroidLocal);
                centroidObject.visible = true;
                return;
            }

            const pathPoints = [];
            const steps = 64;
            const rotationAxis = new THREE.Vector3(0, 1, 0); // Y-axis
            for (let i = 0; i <= steps; i++) {
                const angle = (i / steps) * rotationAngleRad;
                const worldPos = centroidLocal.clone().applyAxisAngle(rotationAxis, angle);
                pathPoints.push(worldPos);
            }

            const pathGeometry = new THREE.BufferGeometry().setFromPoints(pathPoints);
            centroidPathLine = new THREE.Line(pathGeometry, centroidPathMaterial);
            scene.add(centroidPathLine);

            centroidObject.position.copy(pathPoints[pathPoints.length - 1]);
            centroidObject.visible = true;
        }

        window.updateInfoAndCalculations = function() {
             const lengthOA = sideA;
             const lengthOB = sideB;
             const lengthAB = Math.sqrt(sideA * sideA + sideB * sideB);
             const totalLength = lengthOA + lengthOB + lengthAB;
             if (totalLength === 0) return;

             const xG_local = (sideB * (sideB + lengthAB)) / (2 * totalLength);
             const yG_local = (sideA * (sideA + lengthAB)) / (2 * totalLength);
             const distRg_Y = xG_local;
             const guldinArea = totalLength * rotationAngleRad * distRg_Y;

             lengthEl.textContent = totalLength.toFixed(2);
             centroidXEl.textContent = xG_local.toFixed(3);
             centroidYEl.textContent = yG_local.toFixed(3);
             distRgEl.textContent = distRg_Y.toFixed(3);
             angleRadDisplayEl.textContent = rotationAngleRad.toFixed(2);
             guldinAreaEl.textContent = guldinArea.toFixed(3);
             
             
             
             

const texString = `
\\begin{gather*}
\\mathbf{Calcul\\ de\\ } x_G \\mathbf{\\ (R_G\\ rot./Oy)} \\\\
L_{OA} = ${sideA.toFixed(1)} \\\\
L_{OB} = ${sideB.toFixed(1)} \\\\
L_{AB} = \\sqrt{a^2+b^2} \\approx ${lengthAB.toFixed(2)} \\\\
L = L_{OA} + L_{OB} + L_{AB} \\approx ${totalLength.toFixed(2)} \\\\
S_{A,OA}^{(rot Y)} = 0 \\quad \\text{(sur axe)}\\\\
S_{A,OB}^{(rot Y)} = \\pi b^2 \\approx ${(Math.PI * sideB * sideB).toFixed(2)} \\quad \\text{(disque)}\\\\
S_{A,AB}^{(rot Y)} = \\pi b L_{AB} \\approx ${(Math.PI * sideB * lengthAB).toFixed(2)} \\quad \\text{(cône)}\\\\
S_{A,Oy}^{(total)} = S_{A,OB}^{(rot Y)} + S_{A,AB}^{(rot Y)} \\approx ${(Math.PI * sideB * (sideB + lengthAB)).toFixed(2)} \\\\
x_G = R_{G,Oy} = \\frac{S_{A,Oy}^{(total)}}{2\\pi L} \\\\
x_G = \\\\ % This line break should now work reliably
\\frac{\\cancel{\\pi} b (b + \\sqrt{a^2+b^2})}{2\\cancel{\\pi} (a+b+\\sqrt{a^2+b^2})} \\approx ${xG_local.toFixed(3)}
\\end{gather*}
`;
             
             
             
             
             requestAnimationFrame(() => {
                 calcDetailsEl.innerHTML = texString;
                 if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                     MathJax.typesetPromise([calcDetailsEl]).catch((err) => console.error('MathJax typesetting error:', err));
                 } else { console.warn("MathJax not ready for typesetting."); }
             });
        }

        function handleParamChange() {
             sideA = Math.max(0.1, parseFloat(sideAInput.value) || 0.1);
             sideB = Math.max(0.1, parseFloat(sideBInput.value) || 0.1);
             sideAInput.value = sideA;
             sideBInput.value = sideB;

             createOrUpdateTriangle();
             createOrUpdateGrid();
             createOrUpdateSurfaces();
             createOrUpdateCentroidPath();
             updateInfoAndCalculations();
             controls.target.set(sideB / 2, sideA / 2, 0);
             createOrUpdateAxisLabels();
         }

        function handleAngleChange() {
            const angleDeg = parseFloat(angleSlider.value);
            rotationAngleRad = THREE.MathUtils.degToRad(angleDeg);
            angleOutput.textContent = angleDeg;

            createOrUpdateSurfaces();
            createOrUpdateCentroidPath();
            updateInfoAndCalculations();
        }

        function onWindowResize() {
            const aspect = container.clientWidth / container.clientHeight;
            camera.aspect = aspect;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
             Object.values(axisLabels).forEach(label => { if (label) label.quaternion.copy(camera.quaternion); });
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
